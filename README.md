
## 什么是正则表达式 ？

> 正则表达式是一种被用于从文本中检索符合某些特定模式的文本。

正则表达式是从左到右来匹配一个字符串的。“Regular Expression”这个词太长了，我们通常使用它的缩写“regex”或者“regexp”。
正则表达式可以被用来替换字符串中的文本、验证表单、基于模式匹配从一个字符串中提取字符串等等。

## 目录

## 1. 基本匹配

## 2. 元字符

元字符是正则表达式的基本组成元素。元字符在这里跟它通常表达的意思不一样，而是以某种特殊的含义去解释。有些元字符在写在方括号内时有特殊含义。
元字符如下：

|元字符|描述|
|:----:|----|
|.|匹配除换行符以外的任意字符。|
|&#124;|分支结构，匹配符号之前的字符或后面的字符。|
|&#92;|转义符，它可以还原元字符原来的含义，允许你匹配保留字符 <code>[ ] ( ) { } . * + ? ^ $ \ &#124;</code>|
|()|字符串分组,标记一个子表达式的开始和结束位置。子表达式匹配内容使用\1表示替换|
|[ ]|字符类/集，匹配方括号中包含的任意字符。[abc]：匹配字符集合中的任意一个字符（a、b或c）。|
|[^ ]|否定字符类/集。匹配方括号中不包含的任意字符|
|**边界符**|**定位符**|
|^|匹配行的开始|
|$|匹配行的结束|
|\s|匹配空格符：`[\t\n\f\r\p{Z}]`|
|\S|匹配非空格符：`[^\s]`|
|**限定符**|**量词**|
|*|匹配前面的子表达式零次或多次|
|+|匹配前面的子表达式一次或多次|
|?|匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。|
|{n,m}|花括号，匹配前面字符至少 n 次，但是不超过 m 次。|
|(xyz)|字符组，按照确切的顺序匹配字符 xyz。|
|**转义符**|**定义**|
|\w|匹配所有字母和数字的字符：`[a-zA-Z0-9_]`|
|\W|匹配非字母和数字的字符：`[^\w]`|
|\d|匹配数字：`[0-9]`|
|\D|匹配非数字：`[^\d]`|
|\b|匹配单词边界，即字与空格之间的位置，例如：‘cd\b’会匹配‘abcd’，而不会匹配‘abcde’|
|\B|匹配非单词边界|
|\n|匹配换行符|
|\f|匹配换页符|
|\r|匹配回车符|
|\t|匹配制表符|
|\v|匹配垂直制表符|
|\p|	匹配 CR/LF(等同于 \r\n)，用来匹配 DOS 行终止符|


## 2.5 小括号（分组）
括号在正则中的功能就是用于分组。简单来理解就是，由多个元字符组成某个部分，应该被看成一个整体的时候，可以用括号括起来表示一个整体，这是括号的一个重要功能。
- 分组与编号
当正则表达式中使用小括号时，被括号括起来的部分“子表达式”会被保存成一个子组。那分组和编号的规则是就是`第几个括号就是第几个分组`。这意味着匹配到的、该分组的内容，可以在后续的操作中被单独提取或使用。
- 非捕获分组
在括号里面的会保存成子组，但有些情况下，你可能只想用括号将某些部分看成一个整体，后续不用再用它，类似这种情况，在实际使用时，是没必要保存子组的。这时我们可以在括号里面使用 `?:` 不保存子组。
如果正则中出现了括号，那么我们就认为，这个子表达式在后续可能会再次被引用，所以不保存子组可以提高正则的性能。除此之外呢，这么做还有一些好处，由于子组变少了，正则性能会更好，在子组计数时也更不容易出错。那到底啥是不保存子组呢？我们可以理解成，**括号只用于归组，把某个部分当成“单个元素”，不分配编号，后面不会再进行这部分的引用。**

- 分组引用
在知道了分组引用的编号 （number）后，大部分情况下，我们就可以使用 “反斜扛 + 编号”，即 \number 的方式来进行引用，而 JavaScript 中是通过$编号来引用，如$1。
```language
const str = "aaa,bbb,ccc"
str.replace(/(\w+),(\w+),(\w+)/, "\3,\2,\1");//输出'ccc,bbb,aaa'
```

\1代表第一个(\w+)匹配到的内容，即aaa
\2代表第一个(\w+)匹配到的内容，即bbb
\3代表第一个(\w+)匹配到的内容，即ccc
在知道了分组引用的编号 （number）后，大部分情况下，我们就可以使用 “反斜扛 + 编号”，即 \number 的方式来进行引用，而 JavaScript 中是通过$编号来引用，如$1。

## 3. 贪婪模式和非贪婪模式（懒惰模式）
正则表达式默认采用贪婪匹配模式，在该模式下意味着尽可能多的匹配。我们可以使用 `?` 将贪婪匹配模式转化为惰性匹配模式。

- 贪婪模式就是尽可能多的匹配，语法`.*`、`\d*`等等，就是元字符或原子与符号*的组合
- 懒惰模式就是尽可能少的匹配，语法`.*?`、`\d*?`等等，就是元字符或原子与符号*?的组合

|代码/语法	|说明|
| - | - |
|{n,}?|	重复n次以上，但尽可能少重复|
|{n,m}?|	重复n到m次，但尽可能少重复|
|??	|重复0次或1次，但尽可能少重复|
|+?	|重复1次或更多次，但尽可能少重复|
|*?	|重复任意次，但尽可能少重复|
## 4. 断言/零宽断言

断言，就是先从全局环顾一遍正则，然后断定结果，再做进一步匹配处理。
断言用于查找某些内容或内容所在的位置，该内容或内容所在位置应满足一定的条件。
以下是正则表达式中使用的断言：***exp所匹配的内容不计入匹配返回的内容***


|表达式	|名称|	描述|
| - | - | - |
|(?=exp)	|正向先行断言	|匹配某个位置，该位置的后面的内容应匹配表达式 exp，例如：`\d+(?=abc)`匹配`123abc`中的`123`,|
|(?!exp)	|负向先行断言	|匹配某个位置，该位置的后面的内容不匹配表达式 exp，例如：`\d{3}(?!\d)`匹配三位数字，而且这三位数字的后面不能是数字；|
|(?<=exp)	|正向后发断言	|匹配某个位置，该位置的前面的内容应匹配表达式 exp（JS不支持）|
|(?<!exp)	|负向后发断言	|匹配某个位置，该位置的前面的内容不匹配表达式 exp（JS不支持）|

## 5. 修饰符/ 标记

标记也称为修饰符，因为它会修改正则表达式的输出。这些标志可以以任意顺序或组合使用，并且是正则表达式的一部分。
示例：`/abc/g`、`/abc/i`、`/abc/gi`、`/abc/gm`

|标记|描述|
|:----:|----|
|i|不区分大小写：将匹配设置为不区分大小写。|
|g|全局搜索：搜索整个输入字符串中的所有匹配。|
|m|多行匹配：会匹配输入字符串每一行。|



## 常用正则表达式

* **正整数**：`^\d+$`
* **负整数**：`^-\d+$`
* **电话号码**：`^+?[\d\s]{3,}$`
* **电话代码**：`^+?[\d\s]+(?[\d\s]{10,}$`
* **整数**：`^-?\d+$`
* **用户名**：`^[\w\d_.]{4,16}$`
* **字母数字字符**：`^[a-zA-Z0-9]*$`
* **带空格的字母数字字符**：`^[a-zA-Z0-9 ]*$`
* **密码**：`^(?=^.{6,}$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$`
* **电子邮件**：`^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4})*$`
* **IPv4 地址**：`^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$`
* **小写字母**：`^([a-z])*$`
* **大写字母**：`^([A-Z])*$`
* **网址**：`^(((http|https|ftp):\/\/)?([[a-zA-Z0-9]\-\.])+(\.)([[a-zA-Z0-9]]){2,4}([[a-zA-Z0-9]\/+=%&_\.~?\-]*))*$`
* **VISA 信用卡号码**：`^(4[0-9]{12}(?:[0-9]{3})?)*$`
* **日期（MM/DD/YYYY）**：`^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]{2}$`
* **日期（YYYY/MM/DD）**：`^(19|20)?[0-9]{2}[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$`
* **万事达信用卡号码**：`^(5[1-5][0-9]{14})*$`

**[⬆ top](#什么是正则表达式-)**
